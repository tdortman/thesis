\section{Data Structure Design}
\label{sec:implementation:data-structure-design}

The design of the GPU-accelerated Cuckoo filter emphasizes compile-time configuration and a memory layout optimized for parallel access patterns. This section details these design choices, from the high-level configuration structure down to the public-facing API.

\subsection{Compile-Time Configuration}
\label{sec:implementation:data-structure-design:comptime-config}

To maximize performance by allowing the compiler to generate highly specialized code, the filter's core parameters are defined at compile-time as template arguments. These parameters are consolidated into a single configuration structure, \texttt{CuckooConfig}, which provides a clean and explicit way to instantiate the filter. The primary configuration options are:

\begin{itemize}
  \item \texttt{bitsPerTag}: Defines the size of each fingerprint in bits. Has to be 8, 16, or 32.

  \item \texttt{bucketSize}: Specifies the number of fingerprints stored in each bucket. A smaller bucket size generally leads to a lower false positive rate but can negatively impact insertion performance and overall occupancy. A default of 16 was chosen through empirical performance testing.

  \item \texttt{maxEvictions}: Sets the maximum number of evictions a single thread is allowed to perform during an insertion attempt before it gives up and reports a failure. The default value of 500 was determined empirically.

  \item \texttt{blockSize}: Configures the thread block size for the internal CUDA kernels. This parameter can be tuned to optimize GPU occupancy for different hardware architectures. A default of 256 was chosen through empirical testing.

  \item \texttt{AltBucketPolicy}: A class which encapsulates the logic for hashing items, calculating the required number of buckets, and deriving an item's alternate bucket. The default implementation uses the standard XOR-based partial-key cuckoo hashing, but an alternative based on the "Additive and Subtractive" Cuckoo filter \cite{add-sub-cuckoo-filter} has also been implemented to demonstrate this flexibility.

  \item \texttt{evictionPolicy}: The policy used to handle insertions into full buckets. The default implementation employs a Breadth-First Search (BFS) strategy. Unlike the traditional greedy (DFS) approach which immediately evicts a random victim, the BFS policy first scans the alternate buckets of the existing items to find an empty slot. As detailed in Section \ref{sec:implementation:optimisation-techniques:eviction}, this strategy minimizes the length of eviction chains and reduces global memory traffic.

  \item \texttt{WordType}: Specifies the underlying integer type used for atomic operations and fingerprint storage. The default is \texttt{uint64\_t}, which is generally optimal for modern GPU architectures. However, this can be reconfigured (e.g., to \texttt{uint32\_t}) to align with specific hardware characteristics regarding atomic throughput. A benchmarking utility is provided to help users determine the optimal setting, which is primarily useful in cache-resident workloads.
\end{itemize}

Throughout the implementation, static assertions are used to enforce important invariants at compile time, such as ensuring that certain parameters are powers of two to allow for efficient bitwise AND operations instead of more costly modulo arithmetic.

\subsection{Memory Layout and State Management}
\label{sec:implementation:mem-layout-state}

The filter's primary data storage is a single, contiguous array of fixed-size buckets allocated in the GPU's global memory. To maximize memory bandwidth and avoid misaligned access, the internal layout is carefully structured:

\begin{itemize}
  \item Each bucket is composed of an array of 64-bit unsigned integer words.

  \item Fingerprints (tags) are tightly packed within these 64-bit words. For example, a 64-bit word can hold eight 8-bit fingerprints or four 16-bit fingerprints.
\end{itemize}

While this packed layout necessitates the use of bitwise shift and mask operations to extract individual fingerprints, the additional computational cost of these operations is negligible compared to the latency of memory access, making this a highly beneficial trade-off.

Furthermore, this enables the use of SWAR (SIMD Within A Register) techniques. Bitwise magic numbers can be used to search for empty slots (zero detection) or matching tags (XOR comparison) in parallel within a single register \cite{bit-twiddling-hacks}. This eliminates the need for branching loops when iterating over slots within a word.

The filter's state is maintained by a single global atomic counter that tracks the total number of occupied slots. This counter resides in device memory and is updated atomically by the insertion and deletion kernels. Its value is only lazily copied to the host when an explicit query is made, minimizing host-device communication.

Due to a limitation of CUDA C++ where kernels cannot be class members, the implementation passes a pointer to the filter's class instance to each launched kernel. This allows the threads to access the filter's configuration and state, such as data pointers and capacity, as needed.

\subsection{Public API}
\label{sec:implementation:api}

The filter exposes a comprehensive public interface for easy integration. Two sets of APIs are provided: a traditional C-style API that operates on raw device pointers and item counts, and, if the Thrust library is available, a set of convenience wrappers that accept \texttt{thrust::device\_vector} objects.

\subsubsection{\texttt{explicit CuckooFilter(size\_t capacity)}}

The constructor takes a single argument for the desired capacity in terms of the number of items. It guarantees that at least this many items can be stored. Depending on the chosen \texttt{AltBucketPolicy}, the actual allocated capacity may be larger. For example, the default XOR-based strategy requires the number of buckets to be a power of two, so the requested capacity is rounded up to the next suitable size.

\subsubsection{\texttt{size\_t insertMany(const T* d\_keys, const size\_t n)}}

This function attempts to insert a batch of \texttt{n} items from a buffer in device memory pointed to by \texttt{d\_keys}. It is the caller's responsibility to ensure the pointer is valid and the buffer is sufficiently large. The function returns the updated total number of occupied slots in the filter after the insertion attempt.

\subsubsection{\texttt{size\_t insertManySorted(const T* d\_keys, const size\_t n)}}

To address the performance penalties of random memory access, this variant introduces a pre-sorting step. The algorithm computes bucket indices and fingerprints, packs them into key-value pairs, and sorts them via CUB's radix sort before insertion begins. This ensures that consecutive threads target contiguous memory regions. While this strategy yields performance gains for massive datasets by minimizing DRAM transaction overhead, the added computational cost of sorting makes it less efficient for smaller filters that already fit within the GPU cache.

\subsubsection{\texttt{void containsMany(const T* d\_keys, const size\_t n, bool* d\_output)}}

Performs a batch lookup for \texttt{n} items. The results are written to the \texttt{d\_output} device buffer, where the boolean at each index corresponds to whether the item at the same index in \texttt{d\_keys} was found.

\subsubsection{\texttt{size\_t deleteMany(const T* d\_keys, const size\_t n, bool* d\_output = nullptr)}}

Performs a batch deletion of \texttt{n} items. If the optional \texttt{d\_output} buffer is provided, the success or failure of each individual deletion is reported in the same manner as the lookup operation.

\subsubsection{\texttt{void clear()}}

Resets the internal state of the filter by setting all buckets and the occupancy counter to zero. This operation does not deallocate any device memory.

\subsubsection{\texttt{float loadFactor()}}

Returns the current load factor of the filter, calculated as the number of occupied slots divided by the total capacity.

\subsubsection{\texttt{size\_t countOccupiedSlots()}}

A debugging utility that provides a ground-truth count of occupied slots. It operates by copying the entire filter data to the host and manually counting every non-zero fingerprint. As this is an extremely slow, synchronous operation, it should only be used for verification purposes if the internal atomic counter is suspected to be inaccurate.
