\section{Data Structure Design}
\label{sec:implementation:data-structure-design}

The design of the GPU-accelerated Cuckoo filter emphasises compile-time configuration and a memory layout optimised for cache-friendly access patterns.
This section details these design choices, from the high-level configuration structure down to the public-facing API.

\subsection{Compile-Time Configuration}
\label{sec:implementation:data-structure-design:comptime-config}

To maximise performance by allowing the compiler to generate highly specialised code, the filter's core parameters are defined at compile-time as template parameters.
They are consolidated into a single configuration structure, \texttt{CuckooConfig}, which provides a clean and explicit way to instantiate the filter.
The primary configuration options are:

\begin{itemize}
  \item \texttt{bitsPerTag}: Defines the size of each fingerprint in bits.
    Has to be 8, 16, or 32.

  \item \texttt{bucketSize}: Specifies the number of fingerprints stored in each bucket.
    A smaller bucket size generally leads to a lower false positive rate but can negatively impact performance and overall occupancy.
    A default of 16 was chosen through performance testing (See Section \ref{sec:eval:bucket-size}).

  \item \texttt{maxEvictions}: Sets the maximum number of evictions a single thread is allowed to perform during an insertion attempt before it gives up and reports a failure.
    The default value of 500 was taken from \cite{og-cuckoo-filter}.

  \item \texttt{blockSize}: Configures the thread block size for the internal CUDA kernels.
    This parameter can be tuned to optimise GPU occupancy for different hardware architectures.
    A default of 256 was chosen through empirical testing.

  \item \texttt{AltBucketPolicy}: A class which encapsulates the logic for hashing items, calculating the required number of buckets, and deriving an item's alternate bucket.
    The default implementation uses the standard XOR-based partial-key Cuckoo hashing, but alternatives based on the "Additive and Subtractive" Cuckoo filter \cite{add-sub-cuckoo-filter} and an offset-based version \cite{smaller-cuckoo-filter} have also been implemented to demonstrate this flexibility (See Sections \ref{sec:implementation:optimisation-techniques:bucket-policies} \& \ref{sec:eval:bucket-policies}).

  \item \texttt{evictionPolicy}: The policy used to handle insertions into full buckets.
    The default implementation employs a Breadth-First Search (BFS) strategy.
    Unlike the traditional greedy (DFS) approach which immediately evicts a random victim, the BFS policy first scans the alternate buckets of the existing items to find an empty slot.
    This strategy minimises the length of eviction chains and reduces global memory traffic (See Sections \ref{sec:implementation:optimisation-techniques:eviction} \& \ref{sec:eval:eviction-policies}).

  \item \texttt{WordType}: Specifies the underlying integer type used for atomic operations and fingerprint storage.
    The default is \texttt{uint64\_t}, which is generally optimal for modern GPU architectures.
    However, this can be reconfigured (e.g., to \texttt{uint32\_t}) to align with specific hardware characteristics regarding atomic throughput.
    A benchmarking utility is provided to help users determine the optimal setting, which is primarily useful in cache-resident workloads.
\end{itemize}

Throughout the implementation, static assertions are used to enforce important invariants at compile time, such as ensuring that certain parameters are powers of two to allow for efficient bitwise AND operations instead of more costly modulo arithmetic.

\subsection{Memory Layout and State Management}
\label{sec:implementation:mem-layout-state}

The filter's primary data storage is a single, contiguous array of fixed-size buckets allocated in the GPU's global memory.
To maximise memory bandwidth and avoid misaligned access, the internal layout is carefully structured:

\begin{itemize}
  \item Each bucket is composed of an array of 64-bit unsigned integer words.

  \item Fingerprints (tags) are tightly packed within these 64-bit words.
    For example, a 64-bit word can hold eight 8-bit fingerprints or four 16-bit fingerprints.
\end{itemize}

While this packed layout necessitates the use of bitwise shift and mask operations to extract individual fingerprints, the additional computational cost of these operations is negligible compared to the latency of memory access, making this a highly beneficial trade-off.
Figure \ref{fig:memory-layout} visualises this hierarchical memory layout.

\input{content/03-implementation/figures/memory-layout}

Furthermore, this enables the use of SWAR (SIMD Within A Register) techniques.
Empty slots can be detected directly via bitwise zero-detection, while tag matches are found by first broadcasting the query tag across a word, XOR-ing it with the packed tags, and applying the same zero-detection \cite{bit-twiddling-hacks}.
This eliminates the need for branching loops when scanning slots within a word.

The filter's state is maintained by a single global atomic counter that tracks the total number of occupied slots.
This counter resides in device memory and is updated atomically by the insertion and deletion kernels.
Its value is only lazily copied to the host when an explicit query is made, minimising host-device communication.

\subsection{Public API}
\label{sec:implementation:api}

The filter exposes a comprehensive public interface for easy integration.
Two sets of APIs are provided: a traditional C-style API that operates on raw device pointers and item counts, and, as well as a set of overloaded methods that accept \texttt{thrust::device\_vector} objects.

\subsubsection{Initialisation}

\begin{verbatim}
explicit CuckooFilter(size_t capacity)
\end{verbatim}

The constructor takes a single argument for the desired capacity in terms of the number of items.
It guarantees that at least this many items can be stored.
Depending on the chosen \texttt{AltBucketPolicy}, the actual allocated capacity may be larger.
For example, the default XOR-based strategy requires the number of buckets to be a power of two, so the requested capacity is rounded up to the next suitable size.

\subsubsection{Batch Insertion}

\begin{verbatim}
size_t insertMany(const T* d_keys, const size_t n,
                  bool* d_output = nullptr)
\end{verbatim}

This function attempts to insert a batch of \texttt{n} items from a buffer in device memory pointed to by \texttt{d\_keys}.
It is the caller's responsibility to ensure the pointer is valid and the buffer is sufficiently large.
If the optional \texttt{d\_output} buffer is provided, the success or failure of each individual insertion is reported.
The function returns the updated total number of occupied slots in the filter after the insertion attempt.

\subsubsection{Sorted Batch Insertion}

\begin{verbatim}
size_t insertManySorted(const T* d_keys, const size_t n,
                        bool* d_output = nullptr)
\end{verbatim}

To address the performance penalties of random memory access, this variant introduces a pre-sorting step.
The algorithm computes bucket indices and fingerprints, packs them, and sorts them before insertion begins.
This ensures that consecutive threads target contiguous memory regions.

\subsubsection{Batch Lookup}

\begin{verbatim}
void containsMany(const T* d_keys, const size_t n,
                  bool* d_output)
\end{verbatim}

Performs a batch lookup for \texttt{n} items.
The results are written to the \texttt{d\_output} device buffer, where the boolean at each index corresponds to whether the item at the same index in \texttt{d\_keys} was found.

\subsubsection{Batch Deletion}

\begin{verbatim}
size_t deleteMany(const T* d_keys, const size_t n,
                  bool* d_output = nullptr)
\end{verbatim}

Performs a batch deletion of \texttt{n} items.
If \texttt{d\_output} is provided, it indicates which items were successfully removed.
The function returns the updated total number of occupied slots in the filter after the deletion attempt.

\subsubsection{State Management and Debugging}

The following utility functions are provided for filter maintenance and verification:

\begin{itemize}
  \item \texttt{void clear()}: Resets the internal state of the filter by setting all buckets and the occupancy counter to zero.
    This operation does not deallocate any device memory.

  \item \texttt{float loadFactor()}: Returns the current load factor of the filter, calculated as the number of occupied slots divided by the total capacity.

  \item \texttt{size\_t countOccupiedSlots()}: A debugging utility that provides a ground-truth count of occupied slots.
    It operates by copying the entire filter data to the host and manually counting every non-zero fingerprint.
    As this is an extremely slow, synchronous operation, it should only be used for verification purposes if the internal atomic counter is suspected to be inaccurate.
\end{itemize}
