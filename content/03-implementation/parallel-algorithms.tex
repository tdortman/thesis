\clearpage

\section{Parallel Algorithms}
\label{sec:implementation:parallel-algorithms}

The core of this thesis is the design of parallel algorithms for the Cuckoo filter's primary operations: insertion, lookup, and deletion. These algorithms are designed to be launched as CUDA kernels, where many threads cooperate to process batches of items simultaneously.

\subsection{Insertion}
\label{sec:implementation:insertion}

The parallel insertion algorithm is designed to handle a large batch of items in parallel, with each CUDA thread being responsible for inserting a single item. The process for each thread is as follows:

\begin{enumerate}
  \item \textbf{Hashing and Key Generation}: Each item is first hashed into a 64-bit value using the xxHash64 algorithm, chosen for its high performance and excellent statistical properties. This hash is split: the upper 32 bits derive the fingerprint, and the lower 32 bits determine the primary bucket index. Distinct hash parts are used to avoid fingerprint clustering. The alternate bucket index is then calculated using the partial-key cuckoo hashing scheme (Section \ref{sec:background:cuckoo-filter}).

  \item \textbf{Direct Insertion Attempt}: The thread checks the two candidate buckets. To distribute items evenly and reduce contention on the first slots of a bucket, the thread does not start scanning at index 0. Instead, it uses the item's fingerprint to calculate a pseudo-random starting word index. It then iterates through the bucket's 64-bit words, wrapping around to the beginning. For each word, it utilizes a bitwise SWAR algorithm \cite{bit-twiddling-hacks} to generate a mask of empty slots. If a slot is found, an atomic Compare-And-Swap (CAS) attempts to insert the fingerprint.

  \item \textbf{Eviction Process}: If both candidate buckets are full, the thread initiates the eviction process. It randomly selects one bucket and a random occupied slot within it. It atomically replaces the existing fingerprint (\texttt{tag\_old}) with its own (\texttt{tag\_new}). The evicted fingerprint becomes the new item to insert, and the thread calculates its alternate bucket to continue the process.

  \item \textbf{Termination}: The eviction loop continues until an empty slot is found or a limit on the number of evictions is reached, triggering an insertion failure.
\end{enumerate}

To maintain an accurate count of the total items in the filter without creating a bottleneck on a single atomic counter, a hierarchical reduction is employed. Each thread that successfully inserts an item contributes a +1. These values are first summed efficiently at the warp level using shuffle instructions, then aggregated at the block level using shared memory, and finally, a single atomic addition per block is performed on the global counter in device memory.

% tex-fmt: off
\begin{algorithm}[htbp]
  \caption{Parallel Insertion}
  \label{alg:parallel-insertion}
  \begin{algorithmic}[1]
    \Function{Insert}{key}
      \State $h \gets \mathrm{hash}(\text{key})$
      \State $fp \gets \mathrm{fingerprint}(h)$
      \State $i_1 \gets \mathrm{primary\_index}(h)$
      \State $i_2 \gets \mathrm{alternate\_index}(i_1, fp)$

      \LComment{Phase 1: Try direct insertion using SWAR}
      \If{\Call{TryInsert}{$i_1$, $fp$} \textbf{or} \Call{TryInsert}{$i_2$, $fp$}}
        \State \textbf{return} \texttt{Success}
      \EndIf

      \LComment{Phase 2: Eviction Chain}
      \State $b \gets$ randomly pick $i_1$ or $i_2$
      \State $\text{tag} \gets fp$

      \For{$n = 1$ \textbf{to} \text{maxEvictions}}
        \State $s \gets$ random slot index in bucket $b$
        \LComment{Atomically swap current tag with new tag}
        \State $\text{tag} \gets \text{AtomicExchange}(\text{bucket}[b].\text{slot}[s],\ \text{tag})$
        \State $b \gets \text{alternate\_index}(b, \text{tag})$

        \If{\Call{TryInsert}{bucket $b$, \text{tag}}}
          \State \textbf{return} \texttt{Success}
        \EndIf
      \EndFor

      \LComment{Table too full}
      \LComment{Caller will have to rebuild}
      \State \textbf{return} \texttt{Failure}
    \EndFunction
    \Statex
   \Function{TryInsert}{bucket, tag}
      \State $start \gets (\text{tag} \bmod \text{bucketSize}) / \text{tagsPerWord}$
      \For{$i = 0$ \textbf{to} $\text{wordCount} - 1$}
        \State $idx \gets (start + i) \bmod \text{wordCount}$
        \State \texttt{word} $\gets$ \texttt{bucket}[idx]

        \While{\texttt{word} has empty slots}
          \State \texttt{slot} $\gets$ \Call{FindNextEmpty}{\texttt{word}}
          \If{\text{AtomicCAS}(\texttt{word}, \texttt{EMPTY} $\to$ \texttt{tag} at \texttt{slot})}
            \State \textbf{return} \texttt{True}
          \EndIf
          \State Reload \texttt{word}
        \EndWhile
      \EndFor
      \State \textbf{return} \texttt{False}
    \EndFunction
  \end{algorithmic}
\end{algorithm}
% tex-fmt: on

\FloatBarrier

\subsection{Lookup}
\label{sec:implementation:lookup}

The parallel lookup algorithm is a read-only operation optimized for memory access. Each thread calculates the fingerprint and two bucket indices. Similar to insertion, the thread determines a random starting word based on the fingerprint to avoid checking the same memory locations first for every query.

The key optimization is vectorized, non-atomic memory loads combined with SWAR comparisons. Modern GPU hardware can load 128 bits (16 bytes) in a single instruction. The kernel loads two 64-bit words simultaneously starting from the randomized offset. It then broadcasts the query fingerprint and XORs it with the loaded data to check for matches in parallel using constant-time arithmetic, eliminating branching loops.

% tex-fmt: off
\begin{algorithm}[htbp]
  \caption{Parallel Lookup}
  \label{alg:parallel-lookup}
  \begin{algorithmic}[1]
    \Function{Contains}{key}
      \State $h \gets \mathrm{hash}(\text{key})$
      \State $fp \gets \mathrm{fingerprint}(h)$
      \State $i_1 \gets \mathrm{primary\_index}(h)$
      \State $i_2 \gets \mathrm{alternate\_index}(i_1, fp)$

      \LComment{Check both buckets (read-only, no locking needed)}
      \State \textbf{return} \Call{Find}{$i_1$, $fp$} \textbf{or} \Call{Find}{$i_2$, $fp$}
    \EndFunction
    \Statex
    \Function{Find}{bucket, tag}
      \State \texttt{pattern} $\gets$ \Call{BroadcastTag}{tag}

      \LComment{Random start index aligned to 128-bit boundary}
      \State $start \gets (\text{tag} \bmod \text{bucketSize}) / \text{tagsPerWord}$
      \State $start \gets \text{FloorToEven}(start)$

      \For{$i = 0$ \textbf{to} $\text{wordCount} - 1$ \textbf{step} 2}
        \State $idx \gets (start + i) \bmod \text{wordCount}$
        \State $w_1, w_2 \gets$ \Call{LoadWords}{bucket, $idx$}

        \LComment{Use SWAR to check for matches in parallel}
        \If{\Call{HasZeroByte}{$w_1 \oplus \texttt{pattern}$} \textbf{or} \Call{HasZeroByte}{$w_2 \oplus \texttt{pattern}$}}
            \State \textbf{return} \texttt{Success}
        \EndIf
      \EndFor
      \State \textbf{return} \texttt{Failure}
    \EndFunction
  \end{algorithmic}
\end{algorithm}
% tex-fmt: on

\FloatBarrier

\subsection{Deletion}
\label{sec:implementation:deletion}

The parallel deletion algorithm leverages SWAR to locate and remove items efficiently. Like the other operations, it iterates through the bucket in 64-bit words, starting at a pseudo-random offset derived from the fingerprint.

The thread broadcasts the target tag and uses SWAR to find matches. If a match is found, it attempts an atomic CAS to set the specific slot to \texttt{EMPTY} (zero). If the CAS fails (due to concurrent modification), the thread reloads and retries. This ensures thread safety without locking. The operation continues until the item is removed, or the entire bucket has been scanned.

% tex-fmt: off
\begin{algorithm}[htbp]
  \caption{Parallel Deletion}
  \label{alg:parallel-deletion}
  \begin{algorithmic}[1]
    \Function{Remove}{key}
      \State $h \gets \mathrm{hash}(\text{key})$
      \State $fp \gets \mathrm{fingerprint}(h)$
      \State $i_1 \gets \mathrm{primary\_index}(h)$
      \State $i_2 \gets \mathrm{alternate\_index}(i_1, fp)$

      \LComment{Attempt to remove from either valid location}
      \State \textbf{return} \Call{Remove}{$i_1$, $fp$} \textbf{or} \Call{Remove}{$i_2$, $fp$}
    \EndFunction
    \Statex
    \Function{Remove}{bucket, targetTag}
      \State $start \gets (\text{tag} \bmod \text{bucketSize}) / \text{tagsPerWord}$

      \For{$i = 0$ \textbf{to} $\text{wordCount} - 1$}
        \State $idx \gets (start + i) \bmod \text{wordCount}$
        \State \texttt{word} $\gets$ \texttt{bucket}[idx]
        \State \texttt{mask} $\gets$ \Call{SWAR\_Match}{\texttt{word}, \texttt{targetTag}}

        \While{\texttt{mask} is not 0}
           \State \texttt{slot} $\gets$ \Call{FindFirstSet}{\texttt{mask}}

           \LComment{Attempt to atomically set specific slot to EMPTY}
           \If{\text{AtomicCAS}(\texttt{word}, \texttt{targetTag} $\to$ \texttt{EMPTY} at \texttt{slot})}
             \State \textbf{return} \texttt{Success}
           \EndIf

           \LComment{Reload and re-check if CAS failed}
           \State Reload \texttt{word}
           \State \texttt{mask} $\gets$ \Call{SWAR\_Match}{\texttt{word}, \texttt{targetTag}}
        \EndWhile
      \EndFor
      \State \textbf{return} \texttt{Failure}
    \EndFunction
  \end{algorithmic}
\end{algorithm}
% tex-fmt: on

\FloatBarrier