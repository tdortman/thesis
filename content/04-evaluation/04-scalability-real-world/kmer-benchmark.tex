\subsection{Real-World Benchmark: Genomic K-mer Indexing}
\label{sec:eval:kmer}

While synthetic benchmarks using uniformly distributed integers are useful for showing algorithmic behaviour, real-world data can often present challenges due to skewed distributions.
To validate this, a benchmark was conducted on genomic $k$-mer indexing as an important use case for approximate membership query structures in bioinformatics.

\subsubsection{Background and Experimental Setup}

A $k$-mer is a subsequence of length $k$ derived from a biological sequence, such as DNA.
In genomic analysis, counting and filtering $k$-mers is an important step for tasks like genome assembly and error correction.
Since DNA consists of four bases (A, C, G, T), the total number of possible $k$-mers is $4^k$, which grows rather quickly.

For this evaluation, the T2T-CHM13 \cite{t2t-chm13, t2t-y} dataset is used as the first complete sequence of a human genome.
The raw FASTA \cite{fasta} data was pre-processed using KMC 3 \cite{kmc3} to extract all distinct 31-mers ($k$ = 31).
To optimise memory usage and processing speed, the text-based $k$-mers were packed into a 2-bit-per-base binary representation, compressing the dataset roughly by a factor of four and allowing each 31-mer to fit within a single \texttt{uint64\_t}.

The resulting dataset is approximately 20 GB in size (packed), which is sufficient to effectively saturate the 96 GB of VRAM on System B.
All filters were tested for insertion, positive lookup, and deletion (when supported).

\subsubsection{Performance Analysis}

The throughput results for the $k$-mer benchmark are presented in Figure \ref{fig:kmer-benchmark}.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=\textwidth]{images/kmer-benchmark.pdf}
  \caption{Throughput comparison for inserting, querying, and deleting 31-mers from the full T2T-CHM13 human genome on System B.}
  \label{fig:kmer-benchmark}
\end{figure}

The results confirm that the Cuckoo filter's high performance translates well to real-world workloads:

\begin{itemize}
  \item \textbf{Query Performance}: While the Cuckoo filter does not fully match the Blocked Bloom filter, it maintains a notable lead over other dynamic alternatives.
    It is 68\% faster than the GQF and 10.3$\times$ faster than the TCF.

  \item \textbf{Insertion Performance}: While the Cuckoo filter trails the append-only Blocked Bloom filter in this high-bandwidth scenario, it remains the fastest among dynamic data structures, outperforming the TCF by 2.4$\times$ and the GQF by 6.2$\times$.

  \item \textbf{Deletion Performance}: In deletion throughput, the Cuckoo filter demonstrates superior performance.
    It is 2.1$\times$ faster than the GQF and 39.2$\times$ faster than the TCF.
\end{itemize}

\subsubsection{Conclusion}

This benchmark demonstrates that the GPU Cuckoo filter is a highly versatile data structure for real-world applications.
While the Blocked Bloom filter remains the throughput leader for read-only or append-only tasks, the Cuckoo filter is the only tested solution that delivers a consistent high performance across \textit{all} operations.
This makes it particularly valuable for workloads that involve a good mix of insertions, lookups, and deletions.