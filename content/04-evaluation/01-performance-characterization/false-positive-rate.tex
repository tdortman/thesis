\subsection{False Positive Rate}
\label{sec:eval:fpr}

\subsubsection{Empirical Accuracy Analysis}
\label{sec:eval:fpr:empirical}

To evaluate the reliability of the implemented filters, the empirical false positive rate was measured across a range of filter capacities. For each test, the filters were populated to a constant 95\% load factor using random keys. The total memory size was varied from $2^{15}$ to $2^{30}$ bytes, allowing each implementation to optimize its internal layout within that fixed memory constraint. The results are presented in Figure \ref{fig:fpr-vs-memory}:

\begin{itemize}
  \item \textbf{Blocked Bloom filter}: The Blocked Bloom filter demonstrates the highest false positive rate among all tested structures, ranging from approximately 0.5\% to 6\%. This is a known characteristic of the blocked design: partitioning the bit array into small, fixed-size blocks prevents the "averaging" of hash collisions across the entire filter. Consequently, a few heavily congested blocks can disproportionately skew the overall error rate. It is notably the only filter where the false positive rate degrades this much as the total memory size increases.

  \item \textbf{Quotient filter Accuracy}: The GQF exhibits the lowest false positive rate among all candidates, maintaining an error rate below 0.002\%. This confirms the theoretical space efficiency of quotient filters, which handle collisions via Robin Hood hashing and metadata encoding.

  \item \textbf{CPU vs. GPU Cuckoo filters}: A distinction remains visible between the CPU and GPU Cuckoo filter implementations. The CPU version achieves a very low false positive rate, hovering near 0.005\%. The GPU Cuckoo filter, while still highly accurate, exhibits a higher rate of approximately 0.045\%. This difference is a direct consequence of the bucket size trade-off discussed in Section \ref{sec:eval:bucket-size}. To maximize parallel throughput, the GPU implementation uses a bucket size of 16, whereas the CPU versions use a standard bucket size of 4. As established in Equation \ref{eq:cuckoo-space-bound}, a larger bucket size directly increases the collision probability for a fixed fingerprint size. On top of that, the partitioned Cuckoo filter exhibits a similar clustering effect to the Blocked Bloom filter, albeit to a much lesser degree.

  \item \textbf{Comparison with TCF}: The GPU Cuckoo filter significantly outperforms the TCF regarding accuracy. The TCF exhibits an error rate roughly an order of magnitude higher (ranging between 0.2\% and 0.5\%). While the TCF is more accurate than the Blocked Bloom filter, the Cuckoo filter and GQF designs offer superior accuracy for this workload.
\end{itemize}

\begin{figure}[ht!]
  \centering
  \includegraphics[width=\textwidth]{images/fpr.pdf}
  \caption{Comparison of False Positive Rates (FPR) versus total memory size for various filter implementations at a 95\% load factor.}
  \label{fig:fpr-vs-memory}
\end{figure}

\FloatBarrier

\subsubsection{Performance vs. Accuracy Trade-off}
\label{sec:eval:fpr:tradeoff}

In real-world applications, filters are often chosen based on strict False Positive Rate requirements (e.g. $\leq 1\%$ or $\leq 0.1\%$). To evaluate how the filters perform under these constraints, a parameter sweep was conducted to identify the configuration that yields the highest throughput for a given target FPR.

These tests were performed on System B (HBM3) with capacities of $2^{22}$ (L2-resident) and $2^{28}$ (DRAM-resident) slots. The CPU implementations are excluded from this comparison as their throughput is simply insufficient. To represent a realistic workload where the presence of items is uncertain, the query throughput is reported as a weighted average of positive and negative lookups, with a 50\% hit rate.

The results, visualized in Figure \ref{fig:throughput-by-fpr}, highlight the strengths of the Cuckoo filter as a general-purpose structure:

\begin{itemize}
  \item \textbf{L2-Resident Superiority}: In the L2-resident scenario, the GPU Cuckoo filter demonstrates exceptional efficiency. For target FPRs of $\leq 10\%$, $\leq 1\%$ and $\leq 0.1\%$, it surpasses the Blocked Bloom filter in query throughput. This indicates that when memory latency is neutralized by the cache, the Cuckoo filter's retrieval logic is computationally more efficient than the multiple hashing and bitwise operations required by the Blocked Bloom filter. Furthermore, the performance gap between the Cuckoo filter and the other dynamic filters (TCF, GQF) widens significantly in this scenario, as the latter struggle to fully utilize the L2 bandwidth due to their complex internal synchronization.

  \item \textbf{Baseline Comparison}: As expected for the DRAM-resident case, the Blocked Bloom filter generally offers the highest raw throughput due to its linear memory access patterns. However, its inability to support deletions rules it out for dynamic applications. Among the dynamic filters, the Cuckoo filter remains the closest competitor to the Bloom filter's performance across all sizes.

  \item \textbf{Dynamic Operation Performance}: While the GQF can match the Cuckoo filter in query throughput for specific configurations, it suffers a catastrophic penalty in dynamic operations. Its insertion and deletion throughputs are orders of magnitude lower due to the complex synchronization required to shift elements. Similarly, the TCF, while faster than the GQF for updates, still lags significantly behind the Cuckoo filter in deletion throughput.

  \item \textbf{Conclusion}: The GPU Cuckoo filter emerges as the most robust and well-rounded solution for high-throughput dynamic workloads. It is the only tested data structure capable of maintaining high performance for insertions, lookups, \textit{and} deletions simultaneously, while satisfying strict accuracy constraints.
\end{itemize}

\begin{figure}[ht!]
  \centering
  \includegraphics[width=\textwidth]{images/throughput-by-fpr.pdf}
  \caption{Maximum achievable throughput for Insert, Query, and Delete operations while adhering to strict False Positive Rate targets. Top: L2-resident,  Bottom: DRAM-resident. Note the logarithmic scale on the Y-axis.}
  \label{fig:throughput-by-fpr}
\end{figure}

\FloatBarrier
