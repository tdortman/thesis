{"rule":"CD_NN","sentence":"^\\QTwo Choice Filter.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QDissertation   toc\\E$"}
{"rule":"WHITESPACE_RULE","sentence":"^\\QDissertation   toc\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QCoNEXT '14\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QPerf join: An alternative to two-way semijoin and bloomjoin\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QOptimal semijoins for distributed database systems\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QNGSReadsTreatmentâ€“a Cuckoo Filter-based tool for removing duplicate reads in NGS data\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qeach word word1, word2 \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q to tagsPerWord extractTag(word, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q) == tag currentWordIdx = pairIdx + (word == word2) return currentWordIdx * tagsPerWord + \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q return -1 Deletion.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qeach word word1, word2 \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q to tagsPerWord extractTag(word, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q) == tag return Success return -1 Deletion.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qeach word word1, word2 \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q to tagsPerWord extractTag(word, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q) == tag return Success return Failure Deletion.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qexplicit CuckooFilter(sizet capacity).\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\Qexplicit CuckooFilter(sizet capacity).\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qsizet insertMany(const T* dkeys, const sizet n).\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\Qsizet insertMany(const T* dkeys, const sizet n).\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QThis function attempts to insert a batch of n items from a buffer in device memory pointed to by dkeys.\\E$"}
{"rule":"COMMA_COMPOUND_SENTENCE_2","sentence":"^\\QIt is the caller's responsibility to ensure the pointer is valid and the buffer is sufficiently large.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qsizet insertManySorted(const T* dkeys, const sizet n).\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\Qsizet insertManySorted(const T* dkeys, const sizet n).\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_BEGINNING_RULE","sentence":"^\\QThis approach generally outperforms the standard insertMany when the filter is too large to fit into the GPU's L2 cache.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QThis approach generally outperforms the standard insertMany when the filter is too large to fit into the GPU's L2 cache.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qvoid containsMany(const T* dkeys, const sizet n, bool* doutput).\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\Qvoid containsMany(const T* dkeys, const sizet n, bool* doutput).\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QThe results are written to the doutput device buffer, where the boolean at each index corresponds to whether the item at the same index in dkeys was found.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qsizet deleteMany(const T* dkeys, const sizet n, bool* doutput = nullptr).\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\Qsizet deleteMany(const T* dkeys, const sizet n, bool* doutput = nullptr).\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QIf the optional doutput buffer is provided, the success or failure of each individual deletion is reported in the same manner as the lookup operation.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qvoid clear().\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qfloat loadFactor().\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\Qfloat loadFactor().\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qsizet countOccupiedSlots().\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\Qsizet countOccupiedSlots().\\E$"}
{"rule":"A_INFINITIVE","sentence":"^\\QFor example, the GPU can be copying the next chunk of data from the host while simultaneously processing the current chunk, effectively hiding the latency of the PCIe bus transfer and keeping the compute cores busy.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QProceedings of the 28th ACM SIGPLAN Annual Symposium on Principles and Practice of Parallel Programming\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QPPoPP '23\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QSTOC '94\\E$"}
{"rule":"EN_SPECIFIC_CASE","sentence":"^\\QRobin hood hashing\\E$"}
{"rule":"SMALL_NUMBER_OF","sentence":"^\\QOperations on the quotient filter require only a small number of contiguous accesses.\\E$"}
{"rule":"SENTENCE_WHITESPACE","sentence":"^\\QThe paper then gives two data structures, the buffered quotient filter and the cascade filter, which exploit the quotient filter advantages and thus serve as SSD-optimized alternatives to the Bloom filter.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QProc.\\E$"}
{"rule":"A_RB_NN","sentence":"^\\QWhile CPU-based dynamic filters exist, many modern applications generate data at a rate or scale that creates a performance bottleneck, motivating the need for a massively parallel, GPU-accelerated solution.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QBigtable: A distributed storage system for structured data\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QACM Transactions on Computer Systems (TOCS)\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QProceedings of the 2006 ACM SIGMOD international conference on Management of data\\E$"}
{"rule":"ADMIT_ENJOY_VB","sentence":"^\\QRather, they are used to evaluate how the algorithms respond to high-bandwidth memory (HBM) versus standard graphics memory (GDDR).\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_BEGINNING_RULE","sentence":"^\\QDeletion Performance on System A (GDDR7).\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_BEGINNING_RULE","sentence":"^\\QDeletion Performance on System B (HBM3).\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_BEGINNING_RULE","sentence":"^\\QQuery Performance on System B (HBM3) for a DRAM-resident filter.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_BEGINNING_RULE","sentence":"^\\QDeletion Performance on System A (GDDR7) for a L2-resident filter.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_BEGINNING_RULE","sentence":"^\\QDeletion Performance on System B (HBM3) for a L2-resident filter.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_BEGINNING_RULE","sentence":"^\\QDeletion Performance on System A (GDDR7) for an L2-resident filter.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_BEGINNING_RULE","sentence":"^\\QDeletion Performance on System B (HBM3) for an L2-resident filter.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_BEGINNING_RULE","sentence":"^\\QL1 (left) and L2 (right) cache hit rates for the Delete operation across varying filter capacities.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_BEGINNING_RULE","sentence":"^\\QL1 and L2 cache hit rates for the Delete operation across varying filter capacities.\\E$"}
{"rule":"IT_IS_2","sentence":"^\\QWhile the static Blocked Bloom filter maintains a performance lead of approximately 2x due to its much simpler, append-only memory access pattern, the Cuckoo filter establishes itself as the clear performance leader among dynamic data structures.\\E$"}
{"rule":"IT_IS_2","sentence":"^\\QWhile the static Blocked Bloom filter maintains a performance lead of approximately 2x due to its much simpler, append-only memory access pattern, the Cuckoo filter establishes itself as the clear performance leader among the dynamic data structures.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_BEGINNING_RULE","sentence":"^\\QInsert Throughput on System C (DRAM-Resident).\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_BEGINNING_RULE","sentence":"^\\QInsert Throughput on System C (L2-Resident).\\E$"}
{"rule":"CD_NN","sentence":"^\\QBy checking up to 8 candidate slots (4 per bucket) before resorting to an eviction, the BFS approach resolves many collisions locally.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_BEGINNING_RULE","sentence":"^\\QThroughput comparison of sorted vs. unsorted insertion on System C (GDDR7).\\E$"}
{"rule":"IT_IS_2","sentence":"^\\QWhile the static Blocked Bloom filter maintains a performance lead due to its much simpler, append-only memory access pattern, the Cuckoo filter establishes itself as the clear performance leader among the dynamic data structures.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_BEGINNING_RULE","sentence":"^\\QDeletion Performance for L2-resident (Top) and DRAM-resident (Bottom) filters.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QFuture iterations could implement an asynchronous command queue, similar to io_uring, to allow clients to submit batches of requests without stalling, further maximizing GPU occupancy.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qenglish  english Abstract Zusammenfassung\\E$"}
{"rule":"WHITESPACE_RULE","sentence":"^\\Qenglish  english Abstract Zusammenfassung\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\Qenglish  english Abstract Zusammenfassung\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\Qenglish\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QAbstract (German) german\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qenglish\\E$"}
{"rule":"A_BIT","sentence":"^\\QBit Twiddling Hacks\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QTryInsertSWAR bucket, tag each word in bucket old = word.loadrelaxed() SWAR Zero Detection Logic mask = GetZeroMask old mask == 0 break\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QbitPos = FindFirstSet mask slot = bitPos / bitsPerTag new = ReplaceTag old, slot, tag\\E$"}
{"rule":"EN_UNPAIRED_BRACKETS","sentence":"^\\Qword.CAS(old, new)) return True CAS failed: old is updated, retry loop return False\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qreturn HasZeroByte check1 or HasZeroByte check2 Deletion.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qmask&& \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q where \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q and \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\Qmask&& \\E(?:Dummy|Ina|Jimmy-)[0-9]+$"}
{"rule":"CD_NN","sentence":"^\\Qmask is not 0 slot \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q FindFirstSet mask\\E$"}
{"rule":"A_RB_NN","sentence":"^\\QWhile CPU-based dynamic filters exist, many modern applications generate data at a rate that creates a performance bottleneck, motivating the need for a massively parallel, GPU-accelerated solution.\\E$"}
{"rule":"THE_SUPERLATIVE","sentence":"^\\QStoring a Sparse Table with 0(1) Worst Case Access Time\\E$"}
{"rule":"ADMIT_ENJOY_VB","sentence":"^\\QRather, they are used to evaluate how the algorithms respond to high-bandwidth memory (HBM) versus standard graphics memory (GDDR) while keeping as many other factors as possible constant.\\E$"}
